import java.lang.System;
import java.lang.StringBuilder;
import java.text.DecimalFormat;
import poly.util.Equatable;
import poly.util.Array;

¦ The DoubleMatrix class represents a matrix with double-precision floating point components.
¦ The matrix components are stored in row-major order and should be provided as such.
¦ @author Vincent Philippe (@vincent64)
¦ @version 0.1
¦ @update 0.3
¦
class+ DoubleMatrix(Matrix) : Matrix.Property, Equatable {
    ¦ The matrix double components.
    ~ const double[] values;

    ¦ Constructs a double matrix with the given rows and columns sizes.
    ¦ Every component are initialized to zero.
    ¦ @param rows the rows count
    ¦ @param columns the columns count
    ¦
    fn+ constructor(const int rows, const int columns) {
        super(rows, columns);
        values = new[rows * columns];
    }

    ¦ Constructs a square double matrix with the given size.
    ¦ Every component are initialized to zero.
    ¦ @param size the matrix size
    ¦
    fn+ constructor(const int size) {
        this(size, size);
    }

    ¦ Constructs a double matrix with the given rows, columns and values.
    ¦ @param rows the rows count
    ¦ @param columns the columns count
    ¦ @param values the component values
    ¦
    fn+ constructor(const int rows, const int columns, double[] values) {
        super(rows, columns);
        this.values = Array.copy(values);
    }

    ¦ Constructs a double matrix with the given values and rows size.
    ¦ @param values the component values
    ¦ @param rows the rows count
    ¦
    fn+ constructor(double[] values, const int rows) {
        super(rows, values.size / rows);
        assert(values.size % rows == 0);
        this.values = Array.copy(values);
    }

    ¦ Returns the value of the component at the given row and column index.
    ¦ @param row the row index
    ¦ @param column the column index
    ¦ @returns the component value
    ¦
    fn+ double get(int row, int column) {
        assert(0 <= row && row < rows) : new Matrix.RowIndexOutOfBoundsException();
        assert(0 <= column && column < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        return values[row * columns + column];
    }

    ¦ Returns the double vector corresponding to the row at the given index.
    ¦ @param index the row index
    ¦ @returns the row vector
    ¦
    fn+ DoubleVector get(int index) {
        return getRow(index);
    }

    ¦ Returns the double vector corresponding to the row at the given row index.
    ¦ @param row the row index
    ¦ @returns the row vector
    ¦
    fn+ DoubleVector getRow(int row) {
        assert(0 <= row && row < rows) : new Matrix.RowIndexOutOfBoundsException();

        //Copy the components subarray
        double[] values = new[columns];
        System.arraycopy(this.values, row * columns, values, 0, columns);

        return new(values);
    }

    ¦ Returns the double vector corresponding to the column at the given column index.
    ¦ @param column the column index
    ¦ @returns the column vector
    ¦
    fn+ DoubleVector getColumn(int column) {
        assert(0 <= column && column < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        //Compute the column components
        double[] values = new[rows];
        for(int i = 0; i < rows; i++)
            values[i] = this.values[i * columns + column];

        return new(values);
    }

    ¦ Returns the trace of the current matrix.
    ¦ @returns the trace
    ¦
    fn+ double trace() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();
        return sum(int i = 0; i < rows; i++) values[i * columns + i];
    }

    fn+ bool isDiagonal() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every non-diagonal component
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++) {
                if(i != j && values[i * columns + j] != 0d)
                    return false;
            }
        }

        return true;
    }

    fn+ bool isHollow() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every diagonal component
        for(int i = 0; i < rows; i++) {
            if(values[i * columns + i] != 0d)
                return false;
        }

        return true;
    }

    fn+ bool isUpperTriangular() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every lower-triangular component
        for(int i = 1; i < rows; i++) {
            for(int j = 0; j < i; j++) {
                if(values[i * columns + j] != 0d)
                    return false;
            }
        }

        return true;
    }

    fn+ bool isLowerTriangular() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every upper-triangular component
        for(int i = 0; i < rows - 1; i++) {
            for(int j = i + 1; j < columns; j++) {
                if(values[i * columns + j] != 0d)
                    return false;
            }
        }

        return true;
    }

    fn+ bool isSymmetric() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every component
        for(int i = 1; i < rows; i++) {
            for(int j = 0; j < i; j++) {
                if(values[i * columns + j] != values[j * columns + i])
                    return false;
            }
        }

        return true;
    }

    ¦ Returns the transpose of the current matrix.
    ¦ @returns the transposed matrix
    ¦
    fn+ DoubleMatrix transpose() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Transpose components
        double[] values = new[this.values.size];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[j * columns + i];
        }

        return new(values, rows);
    }

    ¦ Swaps the given rows.
    ¦ @param row1 the first row
    ¦ @param row2 the second row
    ¦ @returns the resulting double matrix
    ¦
    fn+ DoubleMatrix swapRow(int row1, int row2) {
        assert(0 <= row1 && row1 < rows) : new Matrix.RowIndexOutOfBoundsException();
        assert(0 <= row2 && row2 < rows) : new Matrix.RowIndexOutOfBoundsException();

        //Swap every component in the rows
        double[] values = Array.copy(this.values);
        for(int i = 0; i < columns; i++) {
            double value = values[row1 * columns + i];
            values[row1 * columns + i] = values[row2 * columns + i];
            values[row2 * columns + i] = value;
        }

        return new(values, rows);
    }

    ¦ Swaps the given columns.
    ¦ @param column1 the first column
    ¦ @param column2 the second column
    ¦ @returns the resulting double matrix
    ¦
    fn+ DoubleMatrix swapColumn(int column1, int column2) {
        assert(0 <= column1 && column1 < columns) : new Matrix.ColumnIndexOutOfBoundsException();
        assert(0 <= column2 && column2 < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        //Swap every component in the columns
        double[] values = Array.copy(this.values);
        for(int i = 0; i < rows; i++) {
            double value = values[i * columns + column1];
            values[i * columns + column1] = values[i * columns + column2];
            values[i * columns + column2] = value;
        }

        return new(values, rows);
    }

    ¦ Multiplies the given row with the given double value.
    ¦ @param row the row
    ¦ @param value the double value
    ¦ @returns the resulting double matrix
    ¦
    fn+ DoubleMatrix mulRow(int row, double value) {
        assert(0 <= row && row < rows) : new Matrix.RowIndexOutOfBoundsException();

        //Multiply every component in the row
        double[] values = Array.copy(this.values);
        for(int i = 0; i < columns; i++)
            values[row * columns + i] *= value;

        return new(values, rows);
    }

    ¦ Multiplies the given column with the given double value.
    ¦ @param column the column
    ¦ @param value the double value
    ¦ @returns the resulting double matrix
    ¦
    fn+ DoubleMatrix mulColumn(int column, double value) {
        assert(0 <= column && column < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        //Multiply every component in the column
        double[] values = Array.copy(this.values);
        for(int i = 0; i < rows; i++)
            values[i * columns + column] *= value;

        return new(values, rows);
    }

    ¦ Adds the current double matrix with the given double matrix.
    ¦ @param that the double matrix
    ¦ @returns the resulting double matrix
    ¦
    op+ DoubleMatrix +(DoubleMatrix that) {
        assert(this.rows == that.rows) : new Matrix.MatrixDimensionMismatchException();
        assert(this.columns == that.columns) : new Matrix.MatrixDimensionMismatchException();

        //Add every component
        double[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] + that.values[i];

        return new(values, rows);
    }

    ¦ Subtracts the current double matrix with the given double matrix.
    ¦ @param that the double matrix
    ¦ @returns the resulting double matrix
    ¦
    op+ DoubleMatrix -(DoubleMatrix that) {
        assert(this.rows == that.rows) : new Matrix.MatrixDimensionMismatchException();
        assert(this.columns == that.columns) : new Matrix.MatrixDimensionMismatchException();

        //Subtract every component
        double[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] + that.values[i];

        return new(values, rows);
    }

    ¦ Negates the current matrix.
    ¦ @returns the negated matrix
    ¦
    op+ DoubleMatrix -() {
        //Negate every component
        double[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = -this.values[i];

        return new(values, rows);
    }

    ¦ Multiplies the current double matrix with the given double matrix.
    ¦ @param that the double matrix
    ¦ @returns the resulting double matrix
    ¦
    op+ DoubleMatrix *(DoubleMatrix that) {
        assert(this.columns == that.rows) : new Matrix.MatrixDimensionMismatchException();

        //Multiply every component
        double[] values = new[this.rows * that.columns];
        for(int i = 0; i < this.rows; i++) {
            for(int j = 0; j < that.columns; j++) {
                values[i * this.columns + j] = sum(int k = 0; k < this.columns; k++)
                    this.values[i * this.columns + k] * that.values[k * this.columns + j];
            }
        }

        return new(values, rows);
    }

    ¦ Multiplies the current double matrix with the given double vector.
    ¦ @param vector the double vector
    ¦ @returns the resulting double vector
    ¦
    op+ DoubleVector *(DoubleVector vector) {
        assert(columns == vector.size) : new Matrix.MatrixDimensionMismatchException();

        //Multiply every component
        double[] values = new[rows];
        for(int i = 0; i < rows; i++) {
            values[i] = sum(int k = 0; k < columns; k++)
                this.values[i * columns + k] * vector.values[k];
        }

        return new(values);
    }

    ¦ Multiplies the current double matrix with the given double scalar.
    ¦ @param value the double scalar
    ¦ @returns the resulting double matrix
    ¦
    op+ DoubleMatrix *(double value) {
        double[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] * value;

        return new(values, rows);
    }

    ¦ Applies the current matrix as a linear transformation on the given double vector.
    ¦ @param vector the double vector
    ¦ @returns the transformed vector
    ¦
    op+ DoubleVector call(DoubleVector vector) {
        return this * vector;
    }

    ¦ Returns the double vector corresponding to the row at the given index.
    ¦ @param index the row index
    ¦ @returns the row vector
    ¦
    op+ DoubleVector access(int index) {
        return get(index);
    }

    ¦ Returns whether the current double matrix is equal to the given double matrix.
    ¦ Two matrices are equal if they have the same size and every component are equal.
    ¦ @param that the double matrix
    ¦ @returns true if the matrices are equal
    ¦
    op+ bool ==(DoubleMatrix that) {
        if(this.rows != that.rows) return false;
        if(this.columns != that.columns) return false;

        //Check every component
        for(int i = 0; i < values.size; i++) {
            if(this.values[i] != that.values[i])
                return false;
        }

        return true;
    }

    ¦ Returns whether the current double matrix is not equal to the given double matrix.
    ¦ @param that the double matrix
    ¦ @returns true if the matrices are not equal
    ¦
    op+ bool !=(DoubleMatrix that) {
        return !(this == that);
    }

    op+ bool ==(Object object) {
        if(object !=: DoubleMatrix) return false;
        return this == object:DoubleMatrix;
    }

    op+ bool !=(Object object) {
        return !(this == object);
    }

    fn+ bool equals(Object object) {
        return this == object;
    }

    ¦ Casts the current double matrix to an integer matrix.
    ¦ @returns the integer matrix
    ¦
    fn+ IntMatrix toIntMatrix() {
        int[] values = new[rows * columns];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[i * columns + j]:int;
        }

        return new(values, rows);
    }

    ¦ Casts the current double matrix to a long matrix.
    ¦ @returns the long matrix
    ¦
    fn+ LongMatrix toLongMatrix() {
        long[] values = new[rows * columns];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[i * columns + j]:long;
        }

        return new(values, rows);
    }

    ¦ Casts the current double matrix to a float matrix.
    ¦ @returns the float matrix
    ¦
    fn+ FloatMatrix toFloatMatrix() {
        float[] values = new[rows * columns];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[i * columns + j]:float;
        }

        return new(values, rows);
    }

    fn+ String toString() {
        DecimalFormat format = new("#.####");
        StringBuilder builder = new();

        //Append every component in a table-shaped string
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                builder.append(" ").append(format.format(values[i * columns + j])).append(" ");
            builder.append("\n");
        }

        return builder.toString();
    }

    ¦ Returns the identity matrix with the given size.
    ¦ @param size the matrix size
    ¦ @returns the identity matrix
    ¦
    fn+ # DoubleMatrix newIdentity(int size) {
        DoubleMatrix matrix = new(size);

        //Set diagonal to one
        for(int i = 0; i < size; i++)
            matrix.values[i * matrix.columns + i] = 1d;

        return matrix;
    }
}