import java.lang.System;
import java.lang.StringBuilder;
import java.text.DecimalFormat;
import poly.util.Equatable;
import poly.util.Array;

¦ The FloatMatrix class represents a matrix with single-precision floating point components.
¦ The matrix components are stored in row-major order and should be provided as such.
¦ @author Vincent Philippe (@vincent64)
¦ @version 0.1
¦ @update 0.3
¦
class+ FloatMatrix(Matrix) : Matrix.Property, Equatable {
    ¦ The matrix float components.
    ~ const float[] values;

    ¦ Constructs a float matrix with the given rows and columns sizes.
    ¦ Every component are initialized to zero.
    ¦ @param rows the rows count
    ¦ @param columns the columns count
    ¦
    fn+ constructor(const int rows, const int columns) {
        super(rows, columns);
        values = new[rows * columns];
    }

    ¦ Constructs a square float matrix with the given size.
    ¦ Every component are initialized to zero.
    ¦ @param size the matrix size
    ¦
    fn+ constructor(const int size) {
        this(size, size);
    }

    ¦ Constructs a float matrix with the given rows, columns and values.
    ¦ @param rows the rows count
    ¦ @param columns the columns count
    ¦ @param values the component values
    ¦
    fn+ constructor(const int rows, const int columns, float[] values) {
        super(rows, columns);
        this.values = Array.copy(values);
    }

    ¦ Constructs a float matrix with the given values and rows size.
    ¦ @param values the component values
    ¦ @param rows the rows count
    ¦
    fn+ constructor(float[] values, const int rows) {
        super(rows, values.size / rows);
        assert(values.size % rows == 0);
        this.values = Array.copy(values);
    }

    ¦ Returns the value of the component at the given row and column index.
    ¦ @param row the row index
    ¦ @param column the column index
    ¦ @returns the component value
    ¦
    fn+ float get(int row, int column) {
        assert(0 <= row && row < rows) : new Matrix.RowIndexOutOfBoundsException();
        assert(0 <= column && column < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        return values[row * columns + column];
    }

    ¦ Returns the float vector corresponding to the row at the given index.
    ¦ @param index the row index
    ¦ @returns the row vector
    ¦
    fn+ FloatVector get(int index) {
        return getRow(index);
    }

    ¦ Returns the float vector corresponding to the row at the given row index.
    ¦ @param row the row index
    ¦ @returns the row vector
    ¦
    fn+ FloatVector getRow(int row) {
        assert(0 <= row && row < rows) : new Matrix.RowIndexOutOfBoundsException();

        //Copy the components subarray
        float[] values = new[columns];
        System.arraycopy(this.values, row * columns, values, 0, columns);

        return new(values);
    }

    ¦ Returns the float vector corresponding to the column at the given column index.
    ¦ @param column the column index
    ¦ @returns the column vector
    ¦
    fn+ FloatVector getColumn(int column) {
        assert(0 <= column && column < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        //Compute the column components
        float[] values = new[rows];
        for(int i = 0; i < rows; i++)
            values[i] = this.values[i * columns + column];

        return new(values);
    }

    ¦ Returns the trace of the current matrix.
    ¦ @returns the trace
    ¦
    fn+ float trace() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();
        return sum(int i = 0; i < rows; i++) values[i * columns + i];
    }

    fn+ bool isDiagonal() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every non-diagonal component
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++) {
                if(i != j && values[i * columns + j] != 0f)
                    return false;
            }
        }

        return true;
    }

    fn+ bool isHollow() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every diagonal component
        for(int i = 0; i < rows; i++) {
            if(values[i * columns + i] != 0f)
                return false;
        }

        return true;
    }

    fn+ bool isUpperTriangular() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every lower-triangular component
        for(int i = 1; i < rows; i++) {
            for(int j = 0; j < i; j++) {
                if(values[i * columns + j] != 0f)
                    return false;
            }
        }

        return true;
    }

    fn+ bool isLowerTriangular() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every upper-triangular component
        for(int i = 0; i < rows - 1; i++) {
            for(int j = i + 1; j < columns; j++) {
                if(values[i * columns + j] != 0f)
                    return false;
            }
        }

        return true;
    }

    fn+ bool isSymmetric() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Check every component
        for(int i = 1; i < rows; i++) {
            for(int j = 0; j < i; j++) {
                if(values[i * columns + j] != values[j * columns + i])
                    return false;
            }
        }

        return true;
    }

    ¦ Returns the transpose of the current matrix.
    ¦ @returns the transposed matrix
    ¦
    fn+ FloatMatrix transpose() {
        assert(isSquare()) : new Matrix.NonSquareMatrixException();

        //Transpose components
        float[] values = new[this.values.size];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[j * columns + i];
        }

        return new(values, rows);
    }

    ¦ Swaps the given rows.
    ¦ @param row1 the first row
    ¦ @param row2 the second row
    ¦ @returns the resulting float matrix
    ¦
    fn+ FloatMatrix swapRow(int row1, int row2) {
        assert(0 <= row1 && row1 < rows) : new Matrix.RowIndexOutOfBoundsException();
        assert(0 <= row2 && row2 < rows) : new Matrix.RowIndexOutOfBoundsException();

        //Swap every component in the rows
        float[] values = Array.copy(this.values);
        for(int i = 0; i < columns; i++) {
            float value = values[row1 * columns + i];
            values[row1 * columns + i] = values[row2 * columns + i];
            values[row2 * columns + i] = value;
        }

        return new(values, rows);
    }

    ¦ Swaps the given columns.
    ¦ @param column1 the first column
    ¦ @param column2 the second column
    ¦ @returns the resulting float matrix
    ¦
    fn+ FloatMatrix swapColumn(int column1, int column2) {
        assert(0 <= column1 && column1 < columns) : new Matrix.ColumnIndexOutOfBoundsException();
        assert(0 <= column2 && column2 < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        //Swap every component in the columns
        float[] values = Array.copy(this.values);
        for(int i = 0; i < rows; i++) {
            float value = values[i * columns + column1];
            values[i * columns + column1] = values[i * columns + column2];
            values[i * columns + column2] = value;
        }

        return new(values, rows);
    }

    ¦ Multiplies the given row with the given float value.
    ¦ @param row the row
    ¦ @param value the float value
    ¦ @returns the resulting float matrix
    ¦
    fn+ FloatMatrix mulRow(int row, float value) {
        assert(0 <= row && row < rows) : new Matrix.RowIndexOutOfBoundsException();

        //Multiply every component in the row
        float[] values = Array.copy(this.values);
        for(int i = 0; i < columns; i++)
            values[row * columns + i] *= value;

        return new(values, rows);
    }

    ¦ Multiplies the given column with the given float value.
    ¦ @param column the column
    ¦ @param value the float value
    ¦ @returns the resulting float matrix
    ¦
    fn+ FloatMatrix mulColumn(int column, float value) {
        assert(0 <= column && column < columns) : new Matrix.ColumnIndexOutOfBoundsException();

        //Multiply every component in the column
        float[] values = Array.copy(this.values);
        for(int i = 0; i < rows; i++)
            values[i * columns + column] *= value;

        return new(values, rows);
    }

    ¦ Adds the current float matrix with the given float matrix.
    ¦ @param that the float matrix
    ¦ @returns the resulting float matrix
    ¦
    op+ FloatMatrix +(FloatMatrix that) {
        assert(this.rows == that.rows) : new Matrix.MatrixDimensionMismatchException();
        assert(this.columns == that.columns) : new Matrix.MatrixDimensionMismatchException();

        //Add every component
        float[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] + that.values[i];

        return new(values, rows);
    }

    ¦ Subtracts the current float matrix with the given float matrix.
    ¦ @param that the float matrix
    ¦ @returns the resulting float matrix
    ¦
    op+ FloatMatrix -(FloatMatrix that) {
        assert(this.rows == that.rows) : new Matrix.MatrixDimensionMismatchException();
        assert(this.columns == that.columns) : new Matrix.MatrixDimensionMismatchException();

        //Subtract every component
        float[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] + that.values[i];

        return new(values, rows);
    }

    ¦ Negates the current matrix.
    ¦ @returns the negated matrix
    ¦
    op+ FloatMatrix -() {
        //Negate every component
        float[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = -this.values[i];

        return new(values, rows);
    }

    ¦ Multiplies the current float matrix with the given float matrix.
    ¦ @param that the float matrix
    ¦ @returns the resulting float matrix
    ¦
    op+ FloatMatrix *(FloatMatrix that) {
        assert(this.columns == that.rows) : new Matrix.MatrixDimensionMismatchException();

        //Multiply every component
        float[] values = new[this.rows * that.columns];
        for(int i = 0; i < this.rows; i++) {
            for(int j = 0; j < that.columns; j++) {
                values[i * this.columns + j] = sum(int k = 0; k < this.columns; k++)
                    this.values[i * this.columns + k] * that.values[k * this.columns + j];
            }
        }

        return new(values, rows);
    }

    ¦ Multiplies the current float matrix with the given float vector.
    ¦ @param vector the float vector
    ¦ @returns the resulting float vector
    ¦
    op+ FloatVector *(FloatVector vector) {
        assert(columns == vector.size) : new Matrix.MatrixDimensionMismatchException();

        //Multiply every component
        float[] values = new[rows];
        for(int i = 0; i < rows; i++) {
            values[i] = sum(int k = 0; k < columns; k++)
                this.values[i * columns + k] * vector.values[k];
        }

        return new(values);
    }

    ¦ Multiplies the current float matrix with the given float scalar.
    ¦ @param value the float scalar
    ¦ @returns the resulting float matrix
    ¦
    op+ FloatMatrix *(float value) {
        float[] values = new[this.values.size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] * value;

        return new(values, rows);
    }

    ¦ Applies the current matrix as a linear transformation on the given float vector.
    ¦ @param vector the float vector
    ¦ @returns the transformed vector
    ¦
    op+ FloatVector call(FloatVector vector) {
        return this * vector;
    }

    ¦ Returns the float vector corresponding to the row at the given index.
    ¦ @param index the row index
    ¦ @returns the row vector
    ¦
    op+ FloatVector access(int index) {
        return get(index);
    }

    ¦ Returns whether the current float matrix is equal to the given float matrix.
    ¦ Two matrices are equal if they have the same size and every component are equal.
    ¦ @param that the float matrix
    ¦ @returns true if the matrices are equal
    ¦
    op+ bool ==(FloatMatrix that) {
        if(this.rows != that.rows) return false;
        if(this.columns != that.columns) return false;

        //Check every component
        for(int i = 0; i < values.size; i++) {
            if(this.values[i] != that.values[i])
                return false;
        }

        return true;
    }

    ¦ Returns whether the current float matrix is not equal to the given float matrix.
    ¦ @param that the float matrix
    ¦ @returns true if the matrices are not equal
    ¦
    op+ bool !=(FloatMatrix that) {
        return !(this == that);
    }

    op+ bool ==(Object object) {
        if(object !=: FloatMatrix) return false;
        return this == object:FloatMatrix;
    }

    op+ bool !=(Object object) {
        return !(this == object);
    }

    fn+ bool equals(Object object) {
        return this == object;
    }

    ¦ Casts the current float matrix to an integer matrix.
    ¦ @returns the integer matrix
    ¦
    fn+ IntMatrix toIntMatrix() {
        int[] values = new[rows * columns];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[i * columns + j]:int;
        }

        return new(values, rows);
    }

    ¦ Casts the current float matrix to a long matrix.
    ¦ @returns the long matrix
    ¦
    fn+ LongMatrix toLongMatrix() {
        long[] values = new[rows * columns];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[i * columns + j]:long;
        }

        return new(values, rows);
    }

    ¦ Casts the current float matrix to a double matrix.
    ¦ @returns the double matrix
    ¦
    fn+ DoubleMatrix toDoubleMatrix() {
        double[] values = new[rows * columns];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                values[i * columns + j] = this.values[i * columns + j]:double;
        }

        return new(values, rows);
    }

    fn+ String toString() {
        DecimalFormat format = new("#.####");
        StringBuilder builder = new();

        //Append every component in a table-shaped string
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < columns; j++)
                builder.append(" ").append(format.format(values[i * columns + j]:double)).append(" ");
            builder.append("\n");
        }

        return builder.toString();
    }

    ¦ Returns the identity matrix with the given size.
    ¦ @param size the matrix size
    ¦ @returns the identity matrix
    ¦
    fn+ # FloatMatrix newIdentity(int size) {
        FloatMatrix matrix = new(size);

        //Set diagonal to one
        for(int i = 0; i < size; i++)
            matrix.values[i * matrix.columns + i] = 1f;

        return matrix;
    }
}