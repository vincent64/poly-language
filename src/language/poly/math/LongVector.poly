import java.lang.StringBuilder;
import poly.util.Equatable;
import poly.util.Array;

¦ The LongVector class represents a vector with long integer components.
¦ @author Vincent Philippe (@vincent64)
¦ @version 0.1
¦ @update 0.3
¦
class+ LongVector(Vector) : Vector.Property, Equatable {
    ¦ The vector long components.
    ~ const long[] values;

    ¦ Constructs a long vector with the given size.
    ¦ Every component are initialized to zero.
    ¦ @param size the vector size
    ¦
    fn+ constructor(const int size) {
        super(size);
        values = new[size];
    }

    ¦ Constructs a long vector with the given values.
    ¦ @param values the component values
    ¦
    fn+ constructor(long[] values) {
        super(values.size);
        this.values = Array.copy(values);
    }

    ¦ Returns the value of the index-th component.
    ¦ @param index the component index
    ¦ @returns the component value
    ¦
    fn+ long get(int index) {
        assert(index >= 0 && index < size) : new Vector.IndexOutOfBoundsException();
        return values[index];
    }

    ¦ Returns the length of the vector.
    ¦ @returns the vector length
    ¦
    fn+ double length() {
        return Math.sqrt(sum(int i = 0; i < size; i++) values[i]:double * values[i]:double);
    }

    ¦ Returns the normalized vector.
    ¦ @returns the normalized vector
    ¦
    fn+ DoubleVector normalize() {
        double length = length();

        //Normalize every component
        double[] values = new[size];
        for(int i = 0; i < size; i++)
            values[i] = this.values[i] / length;

        return new(values);
    }

    fn+ bool isUnit() {
        return length() == 1d;
    }

    ¦ Adds the current vector with the given long vector.
    ¦ @param that the long vector
    ¦ @returns the resulting long vector
    ¦
    op+ LongVector +(LongVector that) {
        assert(that.size == size) : new Vector.VectorDimensionMismatchException();

        //Add every component
        long[] values = new[size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] + that.values[i];

        return new(values);
    }

    ¦ Subtracts the current vector with the given long vector.
    ¦ @param that the long vector
    ¦ @returns the resulting long vector
    ¦
    op+ LongVector -(LongVector that) {
        assert(that.size == size) : new Vector.VectorDimensionMismatchException();

        //Subtract every component
        long[] values = new[size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] - that.values[i];

        return new(values);
    }

    ¦ Negates the current vector.
    ¦ @returns the resulting long vector
    ¦
    op+ LongVector -() {
        //Negate every component
        long[] values = new[size];
        for(int i = 0; i < values.size; i++)
            values[i] = -this.values[i];

        return new(values);
    }

    ¦ Multiplies the current vector with the given long scalar.
    ¦ @param value the long scalar
    ¦ @returns the resulting long vector
    ¦
    op+ LongVector *(long value) {
        //Multiply every component
        long[] values = new[size];
        for(int i = 0; i < values.size; i++)
            values[i] = this.values[i] * value;

        return new(values);
    }

    ¦ Performs the dot product with the current vector and the given long vector.
    ¦ @param that the long vector
    ¦ @returns the dot product
    ¦
    op+ long *(LongVector that) {
        assert(that.size == size) : new Vector.VectorDimensionMismatchException();
        return sum(int i = 0; i < size; i++) this.values[i] * that.values[i];
    }

    ¦ Performs the cross product with the current vector and the given long vector.
    ¦ @note This operation is defined only for vectors of size 3.
    ¦ @param that the long vector
    ¦ @returns the cross product
    ¦
    op+ LongVector ^(LongVector that) {
        assert(size == 3) : new Vector.VectorDimensionMismatchException();

        //Compute cross product
        long[] values = new[size];
        values[0] = this.values[1] * that.values[2] - this.values[2] * that.values[1];
        values[1] = this.values[2] * that.values[0] - this.values[0] * that.values[2];
        values[2] = this.values[0] * that.values[1] - this.values[1] * that.values[0];

        return new(values);
    }

    ¦ Returns the value of the index-th component.
    ¦ @param index the component index
    ¦ @returns the component value
    ¦
    op+ long access(int index) {
        return get(index);
    }

    ¦ Returns whether the current long vector is equal to the given long vector.
    ¦ Two vectors are equal if they have the same size and every component are equal.
    ¦ @param that the long vector
    ¦ @returns true if the vectors are equal
    ¦
    op+ bool ==(LongVector that) {
        if(this.size != that.size) return false;

        //Check every component
        for(int i = 0; i < size; i++) {
            if(this.values[i] != that.values[i])
                return false;
        }

        return true;
    }

    ¦ Returns whether the current long vector is not equal to the given long vector.
    ¦ @param that the long vector
    ¦ @returns true if the vectors are not equal
    ¦
    op+ bool !=(LongVector that) {
        return !(this == that);
    }

    op+ bool ==(Object object) {
        if(object !=: LongVector) return false;
        return this == object:LongVector;
    }

    op+ bool !=(Object object) {
        return !(this == object);
    }

    fn+ bool equals(Object object) {
        return this == object;
    }

    ¦ Casts the current long vector to an integer vector.
    ¦ @returns the integer vector
    ¦
    fn+ IntVector toIntVector() {
        int[] values = new[size];
        for(int i = 0; i < size; i++)
            values[i] = this.values[i]:int;

        return new(values);
    }

    ¦ Casts the current long vector to a float vector.
    ¦ @returns the float vector
    ¦
    fn+ FloatVector toFloatVector() {
        float[] values = new[size];
        for(int i = 0; i < size; i++)
            values[i] = this.values[i]:float;

        return new(values);
    }

    ¦ Casts the current long vector to a double vector.
    ¦ @returns the double vector
    ¦
    fn+ DoubleVector toDoubleVector() {
        double[] values = new[size];
        for(int i = 0; i < size; i++)
            values[i] = this.values[i]:double;

        return new(values);
    }

    ¦ Returns the current long vector to a long matrix.
    ¦ The resulting matrix is a matrix with 1 column.
    ¦ @returns the long matrix
    ¦
    fn+ LongMatrix toMatrix() {
        return new(values, size);
    }

    fn+ String toString() {
        StringBuilder builder = new();

        //Append every component
        for(int i = 0; i < size; i++)
            builder.append(" ").append(values[i]).append(" ");

        return builder.toString();
    }
}